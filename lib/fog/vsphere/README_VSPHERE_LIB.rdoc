http://geemus.s3.amazonaws.com/fog.png

fog vsphere is the Ruby vsphere cloud computing library, top to bottom:

* Extend orginal reuqests to enpower fine-grained lifecycle management of virtual machines, flexible resource fetch, and configurations on disk/networking
* Extend collections to enable simplified compute service interface for vsphere cloud

== Verrsion description

  version = 1.3.1.serengeti.1

This version mainly ship latest changes on fog Vsphere cloud provider and do not conclude complete support or required dependency to all providers, which means you should download fog from github for cloud services of other cloud providers, like AMAZON, Rackspace, and so on.
This version extend original vsphere cloud with fine-grained control functions to help elegant lifecycle management of virtual machines, flexible resources fetch, and configs of disk/network.
This work is still undergoing, besides the powerful extensition on requests API, we are working on structure and enhance vsphere cloud services on efficent provisioning, resource placement, and storage/networking management.
Please feel free to touch us: (lxinhui@vmware.com, jxiao@vmware.com, whe@vmware.com)

== Getting Started

  sudo gem install fog

Now type 'fog' to try stuff, confident that fog will let you know what to do. Here is an example of wading through server clone for Vsphere Compute Cloud:

  >> servers = Compute[:vsphere].servers.new
  >> Compute[:vsphere].servers.new
    <Fog::Compute::Vsphere::Server
      id=nil,
      name=nil,
      uuid=nil,
      instance_uuid=nil,
      hostname=nil,
      operatingsystem=nil,
      ipaddress=nil,
      power_state=nil,
      tools_state=nil,
      tools_version=nil,
      mac_addresses=nil,
      hypervisor=nil,
      is_a_template=nil,
      connection_state=nil,
      mo_ref=nil,
      path=nil,
      max_cpu=nil,
      max_mem=nil
    >
   This is not recomend for shortage of meaning arguments but it is indeed suggested to use servers.all or servers.get to fetch all vms or some vm by given id.

  >> server = Compute[:vsphere].servers.clone('name' => "clone_vm_name", 'path' => '/Datacenters/datacenter_name/vm/sample_vm_name', 'wait' => 1,  'linked_clone' => true)
  <Fog::Compute::Vsphere::Server [...]>
  It is proposed to use clone as much as you can to create new vms with consideration of performance.

  >> server.destroy # cleanup after yourself or regret it, trust me
  true

== Collections

A high level interface to each cloud is provided through collections, such as `servers`.
You can see a list of available collections by calling `collections` on the connection object. You can try it out using the `fog` command:

  >> Compute[:vsphere].collections
  [:servers, :volumes, :virtualNetwork]
  servers have been provided with public functions of get and all. volumes and virtualNetwork are still underworking.

Some collections are available across multiple providers:

* compute providers have +servers+
* dns providers have +zones+ and +records+
* storage providers have +directories+ and +files+

Collections share basic CRUD type operations, such as:
* +all+ - fetch every object of that type from the provider.
* +create+ - initialize a new record locally and a remote resource with the provider.
* +get+ - fetch a single object by it's identity from the provider.
* +new+ - initialize a new record locally, but do not create a remote resource with the provider.

As an example, we'll try initializing and persisting a Vsphere Cloud server:

  require 'fog'

  compute = Fog::Compute.new(
      :provider => 'vsphere',
      :vsphere_server => 'ip_of_vc_server',
      :vsphere_username => 'vc_admin_name',
      :vsphere_password => 'vc_password',
      :vsphere_expected_pubkey_hash => 'vc_hash_key'
  })

  # boot a gentoo server (flavor 1 = 256, image 3 = gentoo 2008.0)
  servers = compute.servers.new
  server = servers.clone('name' => "clone_vm_name", 'path' => '/Datacenters/datacenter_name/vm/sample_vm_name', 'wait' => 1,  'linked_clone' => true)
  server.start('instance_uuid' => 'id_number' ) # power on a provisioned vm
  server.stop('instance_uuid' => 'id_number' ) # power off a given vm

  # DO STUFF

  server.destroy # cleanup after yourself or regret it, trust me

== Requests

Commonly, requests allow you to dive deeper when the models just can't cut it.
Primary extention to vsphere cloud provider have been made to Requests part.
You can see a list of available requests by calling #requests on the connection object.

For instance, vsphere provides methods related to config disks for a provisioned vm. Here is how you can create new disks for a given vm:

  $ fog
  >> Compute[:vsphere].vm_create_disk('vm_moid' => 'vm_mob_id', 'path' => '[datastore_name] vm_name/vm_name_sn.vmdk', 'size' => 'disk_size')
  #<Excon::Response [...]>

It will return an {excon}[http://github.com/geemus/excon] response, which has `body`, `headers` and `status`. Both return nice hashes.

== Extentions

Extentions made to vsphere cloud provider are divided into four categories, primarily on Requests and server/servers accordingly. Below are more details:

* First category focus on fine-grianed vm lifecycle control, including extention to vm_clone, vm_power_on, vm_power_off, vm_reboot.
    * It is permitted with extended interfaces for user to clone vm from given template to a fine-defined destination whihc is described by cluster, host, datastore;
    * It is permitted to set detailed cpu and memory desired for a given vm at the moment of clone or at runtime;
    * It is supported to softly stop and reboot a live vm which means stop service running in guest os instead of enforced exit of system;
    * It is permitted to wait for the final status to return no matter for soft or forced start/stop of vm.

* Second category focus on detailed configurations of disk(vm_create_disks/vm_delete_disks), networking(vm_config_ip/vm_update_network), and operations on high level features like High Availability(HA)(vm_config_ha).
    * It is supported to create/delete disks from given datastore for a given vm;
    * It is supported to add a vm with given portgroup;
    * It is supported to config a vm with dhcp or static ip, dns, settings;
    * It is supported to check a vm in a HA cluster or not, and disable HA feature of a protected VM.

* Third category support to query different kinds/levels of resources from vcenter(query_resources.rb), which can be used for resource scheduling optimization and placement of virtul machines.
    * It is supported to fetch all clusters with extensible defined properties belong to a given datacenter;
    * It is supported to fetch all datastores assessible with extensible defined properties from a cluster;
    * It is supported to fetch all resource pools with extensible defined properties belong to a given cluster;
    * It is supported to fetch all hosts with extensible defined properties belong to a given cluster;
    * It is supported to fetch all vms provisioned with extensible defined properties from a given host;
    * It is supported to fetch all datastores assessible with extensible defined properties from a host;
    * It is supported to fetch all progroups(network settings) created for a given datacenter;
    * It is supported to fetch all disks with extensible defined properties for a given vm;
    * It is also supported to fecth all clusters/resourcepools/datastores/hosts/vms/folders in a datacenter at once query to improve efficency.

* Fourth category contains some functions to facilitate above functions, such as transform of arguments from literal variants to proper handles for underlying execution.
    * It is facilitated to transform a management object id into management object which is very useful to talk with vc and execute operatios mentioned above;
    * It is facilitated to get datacenter management object which contains a given vm;
    * It is facilitated to get datacenter/datasore/vm from a given path;
    * It is facilitated to transform object array into property hash for convenience of query and dependent operations at higher level like placement without trivial access to vc database;
    * It is facilitated to wait for a task to finish under parallel invocation without problems caused similar like rbvmomi.

All these functions have been attached with corresponding tests and please refer to more details in test part.


== Copyright

(The MIT License)

Copyright (c) 2010 {geemus (Wesley Beary)}[http://github.com/geemus]

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
